# -*- coding: utf-8 -*-
#
# gPodder - A media aggregator and podcast client
# Copyright (c) 2005-2009 Thomas Perl and the gPodder Team
#
# gPodder is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# gPodder is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
Loads and executes user extensions

Extensions are Python scripts in "$GPODDER_HOME/Extensions". Each script must
define a class named "gPodderExtensions", otherwise it will be ignored.

The extensions class defines several callbacks that will be called by gPodder
at certain points. See the methods defined below for a list of callbacks and
their parameters.

For an example extension see examples/extensions.py
"""

import glob
import imp
import inspect
import json
import os
import functools
import sys
from datetime import datetime

import gpodder
from gpodder import util
from gpodder.jsonconfig import JsonConfig

import logging
logger = logging.getLogger(__name__)

# The class name that has to appear in a extension module
EXTENSION_CLASS = 'gPodderExtension'

# The variable name that stores the extensions parameters
EXTENSION_PARAMS = 'PARAMS'

# The variable name that stores the extensions parameters
EXTENSION_CONFIG = 'DEFAULT_CONFIG'

EXTENSION_FOLDER = 'gpodder_extensions'
FILE_EXTENSION_NAME = 'extension.py'
FILE_META_NAME = 'metadata.json'


def call_extensions(func):
    """Decorator to create handler functions in ExtensionManager

    Calls the specified function in all user extensions that define it.
    """
    method_name = func.__name__

    @functools.wraps(func)
    def handler(self, *args, **kwargs):
        result = None
        for extension_consumer, state in self.modules:
            if state:
                try:
                    callback = getattr(extension_consumer.module, method_name, None)
                    if callback is not None:
                        # If the results are lists, concatenate them to show all
                        # possible items that are generated by all extension together
                        cb_res = callback(*args, **kwargs)
                        if isinstance(result, list) and isinstance(cb_res, list):
                            result.extend(cb_res)
                        elif cb_res is not None:
                            result = cb_res
                except Exception, e:
                    logger.error('Error in %s, function %s: %s', extension_consumer.extension_file,
                            method_name, e, exc_info=True)
        func(self, *args, **kwargs)
        return result

    return handler


class ExtensionParent(object):
    """Super class for every extension"""

    def __init__(self, **kwargs):
        self.metadata = kwargs.get('metadata', None)
        self.config = kwargs.get('config', None)
        self.context_menu_callback = None
        self.notify = gpodder.notify
        self.read_metadata()

        # this code is needed when running the extensions unittests
        if isinstance(self.config, dict) and self.metadata:
            self.config = JsonConfig(data=json.dumps(self.config))
            self.config = getattr(self.config.extensions, self.metadata['id'])

    def read_metadata(self):
        self.id = None
        self.name = None
        self.desc = None
        self.authors = []

        if self.metadata is not None:
            if self.metadata.has_key('id'):
              self.id = self.metadata['id']

            if self.metadata.has_key('name'):
              self.name = self.metadata['name']

            if self.metadata.has_key('desc'):
              self.desc = self.metadata['desc']

            if self.metadata.has_key('authors'):
              self.desc = self.metadata['authors']

    def check_command(self, cmd):
        """Check if a command line command/program exists"""

        import shlex
        import subprocess

        # Prior to Python 2.7.3, this module (shlex) did not support Unicode input.
        if isinstance(cmd, unicode):
            cmd = cmd.encode('ascii', 'ignore')

        program = shlex.split(cmd)[0]
        try:
            subprocess.Popen(shlex.split('%s --version' % program),
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
        except Exception as (errno, errstr):
            raise ImportError('%s: %s' % (errstr, program))

    def notify_action(self, action, episode):
        """method to simple use the notification system"""

        now = datetime.now()

        name = 'gPodder-Extension'
        if self.name is not None:
            name = '%s: %s' % (name, self.name)

        self.notify.message(name, "%s(%s): '%s/%s'" % (action,
            now.strftime('%x %X'), episode.channel.title, episode.title))

    def _show_context_menu(self, episodes):
        """return if a context menu entry should be displayed"""
        return False

    def on_episodes_context_menu(self, episodes):
        """add context menu entry for a specific extension"""

        if self.name is None:
            return None

        if not self._show_context_menu(episodes) or self.context_menu_callback is None:
            return None

        return [(self.name, self.context_menu_callback)]

    def update_episode_file(self, episode, filename):
        """method for simple update an episode with filename information"""

        if not os.path.exists(filename):
            return

        basename, extension = os.path.splitext(filename)

        episode.download_filename = os.path.basename(filename)
        episode.file_size = os.path.getsize(filename)
        episode.mime_type = util.mimetype_from_extension(extension)
        episode.save()
        episode.db.commit()


class ExtensionConsumer(object):
    """A class which manage one extension

    it loads the meta information from metadata.json,
    it loads the extension class from extension.py
    and it loads default configuration
    """

    def __init__(self, config=None, path=None, module=None):
        self.module = module
        self._gpo_config = config
        self.config = None
        self.extension_file = None
        self.metadata = None
        self.params = None

        if path is not None and module is None:
            self.extension_file = os.path.join(path, FILE_EXTENSION_NAME)
            metadata_file = os.path.join(path, FILE_META_NAME)
            self.metadata = self._load_metadata(metadata_file)

        elif path is None and module is not None:
            pass

        else:
            logger.error("ExtensionConsumer couldn't initialize successfully")

    def _load_module(self, filepath):
        path, filename = os.path.split(filepath)
        package_name = os.path.split(path)[1]
        module_name, module_extension = os.path.splitext(filename)

        pkg_file, pkg_path, pkg_desc = imp.find_module(package_name, [ os.path.split(path)[0] ])
        pkg = imp.load_module(package_name, None, pkg_path, pkg_desc)

        module_file, module_path, module_desc = imp.find_module(module_name, pkg.__path__)
        return imp.load_module('%s.%s' % (package_name, module_name),
            file(filepath, 'r'), module_path, module_desc)

    def _load_metadata(self, metadata_file):
        with open(metadata_file, 'r') as f:
            metadata = json.load(f)
        return metadata

    def _load_user_prefs(self, module_file):
        if not self.metadata['id'] in self._gpo_config.extensions.keys():
            config = getattr(module_file, EXTENSION_CONFIG, None)
            if config is not None:
                self._gpo_config.register_defaults(config)

        return getattr(self._gpo_config.extensions, self.metadata['id'])

    def load_extension(self):
        """Load a Python module by filename

        Returns an instance of the EXTENSION_CLASS class defined
        in the module, or None if the module does not contain
        such a class.
        """
        try:
            module_file = self._load_module(self.extension_file)
            self.config = self._load_user_prefs(module_file)
            self.params = getattr(module_file, EXTENSION_PARAMS, None)

            extension_class = getattr(module_file, EXTENSION_CLASS, None)
            self.module = extension_class(
                metadata=self.metadata,
                config=self.config
            )

            logger.info('Module loaded: %s', self.extension_file)
            return None
        except Exception, e:
            logger.error('Cannot load %s: %s', self.extension_file, e, exc_info=True)
            return e

    def revert_settings(self):
        """revert stored extension settings to the default values"""

        if self.metadata['id'] in self._gpo_config.extensions.keys():
            del self._gpo_config.extensions[self.metadata['id']]

            module_file = self._load_module(self.extension_file)

            config = getattr(module_file, EXTENSION_CONFIG, None)
            if config is not None:
                self._gpo_config.register_defaults(config)
                self._gpo_config.save()


class ExtensionManager(object):
    """Manager class for the extensions

    This class loads all available extensions from the filesystem
    it also holds all "hook"-methods which can be used in an
    extension

    """
    DISABLED, ENABLED = range(2)
    EXTENSIONCONSUMER, STATE = range(2)

    def __init__(self, config):
        extension_root_path = self._get_extension_root_path()
        if extension_root_path is None:
            return

        self.modules = []
        enabled_extensions = []
        self._config = config
        enabled_extensions = self._config.extensions.enabled

        pathname = os.path.join(extension_root_path, '*/')
        for extension_path in glob.glob(pathname):
            extension_consumer = ExtensionConsumer(
                config=self._config, path=extension_path)

            state = self.DISABLED
            extension_id = extension_consumer.metadata['id']
            if extension_id in enabled_extensions:
                error = extension_consumer.load_extension()
                if error is None:
                    state = self.ENABLED
                else:
                    state = self.DISABLED
                    enabled_extensions.remove(extension_id)

            self.modules.append((extension_consumer, state, ))

    def register_extensions(self, obj):
        """Register an object that implements some extensions."""

        self.modules.append((ExtensionConsumer(module=obj), self.ENABLED))

    def unregister_extensions(self, obj):
        """Unregister a previously registered object."""

        extension_module = (ExtensionConsumer(module=obj), self.ENABLED)
        if extension_module in self.modules:
            self.modules.remove(extension_module)
        else:
            logger.warn('Unregistered extension which was not registered.')

    def _get_extension_root_path(self):
        """returns the file-system path where the extensions are stored"""

        extension_root_path = os.environ.get('GPODDER_EXTENSIONS', None)
        if extension_root_path is None:
            gpo_folder = os.path.dirname(gpodder.__file__)
            extension_root_path = os.path.join(gpo_folder, EXTENSION_FOLDER)

        if extension_root_path is not None:
            sys.path.append(extension_root_path)

        logger.info('Reading extension script from %s', extension_root_path)
        return extension_root_path

    def get_extensions(self):
        """returns a list of all loaded extensions with the enabled/disable state"""

        enabled_extensions = self._config.extensions.enabled
        for index, (extension_consumer, enabled) in enumerate(self.modules):
            if extension_consumer.metadata:
                if extension_consumer.metadata['id'] in enabled_extensions:
                    enabled = self.ENABLED
                else:
                    enabled = self.DISABLED
                self.modules[index] = (extension_consumer, enabled, )

        return self.modules

    # Define all known handler functions here, decorate them with the
    # "call_extension" decorator to forward all calls to extension scripts that have
    # the same function defined in them. If the handler functions here contain
    # any code, it will be called after all the extensions have been called.

    @call_extensions
    def on_ui_initialized(self, model, update_podcast_callback,
            download_episode_callback):
        """Called when the user interface is initialized.

        @param model: A gpodder.model.Model instance
        @param update_podcast_callback: Function to update a podcast feed
        @param download_episode_callback: Function to download an episode
        """
        pass

    @call_extensions
    def on_podcast_subscribe(self, podcast):
        """Called when the user subscribes to a new podcast feed.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_updated(self, podcast):
        """Called when a podcast feed was updated

        This extension will be called even if there were no new episodes.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_update_failed(self, podcast, exception):
        """Called when a podcast update failed.

        @param podcast: A gpodder.model.PodcastChannel instance

        @param exception: The reason.
        """
        pass

    @call_extensions
    def on_podcast_save(self, podcast):
        """Called when a podcast is saved to the database

        This extensions will be called when the user edits the metadata of
        the podcast or when the feed was updated.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_delete(self, podcast):
        """Called when a podcast is deleted from the database

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_episode_save(self, episode):
        """Called when an episode is saved to the database

        This extension will be called when a new episode is added to the
        database or when the state of an existing episode is changed.

        @param episode: A gpodder.model.PodcastEpisode instance
        """
        pass

    @call_extensions
    def on_episode_downloaded(self, episode):
        """Called when an episode has been downloaded

        You can retrieve the filename via episode.local_filename(False)

        @param episode: A gpodder.model.PodcastEpisode instance
        """
        pass

    @call_extensions
    def on_all_episodes_downloaded(self):
        """Called when all episodes has been downloaded
        """
        pass

    @call_extensions
    def on_episodes_context_menu(self, episodes):
        """Called when the episode list context menu is opened

        You can add additional context menu entries here. You have to
        return a list of tuples, where the first item is a label and
        the second item is a callable that will get the episode as its
        first and only parameter.

        Example return value:

        [('Mark as new', lambda episodes: ...)]

        @param episodes: A list of gpodder.model.PodcastEpisode instances
        """
        pass

    @call_extensions
    def on_episode_delete(self, episode, filename):
        """Called just before the episode's disk file is about to be
        deleted."""
        pass

    @call_extensions
    def on_episode_removed_from_podcast(self, episode):
        """Called just before the episode is about to be removed from
        the podcast channel, e.g., when the episode has not been
        downloaded and it disappears from the feed.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass
