# -*- coding: utf-8 -*-
#
# gPodder - A media aggregator and podcast client
# Copyright (c) 2005-2009 Thomas Perl and the gPodder Team
#
# gPodder is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# gPodder is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
Loads and executes user extensions

Extensions are Python scripts in "$GPODDER_HOME/Extensions". Each script must
define a class named "gPodderExtension", otherwise it will be ignored.

The extensions class defines several callbacks that will be called by gPodder
at certain points. See the methods defined below for a list of callbacks and
their parameters.

For an example extension see examples/extensions.py
"""

import glob
import imp
import inspect
import json
import os
import functools
import shlex
import subprocess
import sys
import re
from datetime import datetime

import gpodder

from gpodder import util

import logging
logger = logging.getLogger(__name__)


def call_extensions(func):
    """Decorator to create handler functions in ExtensionManager

    Calls the specified function in all user extensions that define it.
    """
    method_name = func.__name__

    @functools.wraps(func)
    def handler(self, *args, **kwargs):
        result = None
        for container, enabled in self.containers:
            if not enabled:
                continue

            try:
                callback = getattr(container.module, method_name, None)
                if callback is None:
                    continue

                # If the results are lists, concatenate them to show all
                # possible items that are generated by all extension together
                cb_res = callback(*args, **kwargs)
                if isinstance(result, list) and isinstance(cb_res, list):
                    result.extend(cb_res)
                elif cb_res is not None:
                    result = cb_res
            except Exception, exception:
                logger.error('Error in %s in %s: %s', container.filename,
                        method_name, exception, exc_info=True)
        func(self, *args, **kwargs)
        return result

    return handler

class ExtensionMetadata(object):
    def __init__(self, metadata):
        self.__dict__.update(metadata)

class ExtensionContainer(object):
    """An extension container wraps one extension module"""

    def __init__(self, manager, name, config, filename=None, module=None):
        self.manager = manager

        self.name = name
        self.config = config
        self.filename = filename
        self.module = module

        self.default_config = None
        self.parameters = None
        self.metadata = ExtensionMetadata(self._load_metadata(filename))

    def _load_metadata(self, filename):
        if not filename or not os.path.exists(filename):
            return {}

        extension_py = open(filename).read()
        return dict(re.findall("__([a-z]+)__ = '([^']+)'", extension_py))

    def _load_module(self):
        basename, extension = os.path.splitext(os.path.basename(self.filename))
        return imp.load_module(basename, file(self.filename, 'r'),
            self.filename, (extension, 'r', imp.PY_SOURCE))

    def load_extension(self):
        """Load and initialize the gPodder extension module"""
        if self.module is not None:
            logger.info('Module already loaded.')
            return

        try:
            module_file = self._load_module()
            self.default_config = getattr(module_file, 'DefaultConfig', {})
            self.parameters = getattr(module_file, 'Parameters', {})

            self.module = module_file.gPodderExtension(self)

            logger.info('Module loaded: %s', self.filename)
        except Exception, exception:
            logger.error('Cannot load %s: %s', self.filename, exception,
                    exc_info=True)
            raise


class ExtensionManager(object):
    """Loads extensions and manages self-registering plugins"""

    def __init__(self, config):
        self.containers = []
        self._config = config
        enabled_extensions = self._config.extensions.enabled

        for name, filename in self._find_extensions():
            config = getattr(self._config.extensions, name)
            container = ExtensionContainer(self, name, config, filename)

            if name in enabled_extensions:
                try:
                    container.load_extension()
                except Exception, e:
                    enabled_extensions.remove(name)
                    continue

            self.containers.append((container, name in enabled_extensions))

    def _find_extensions(self):
        root = os.path.abspath(gpodder.__path__[0])
        for filename in glob.glob(os.path.join(root, 'builtins', '*.py')):
            name, _ = os.path.splitext(os.path.basename(filename))
            yield (name, filename)

    def get_extensions(self):
        """Get a list of all loaded extensions and their enabled flag"""

        enabled_extensions = self._config.extensions.enabled
        for index, (container, enabled) in enumerate(self.containers):
            enabled = (container.name in enabled_extensions)
            self.containers[index] = (container, enabled)

        return self.containers

    # Define all known handler functions here, decorate them with the
    # "call_extension" decorator to forward all calls to extension scripts that have
    # the same function defined in them. If the handler functions here contain
    # any code, it will be called after all the extensions have been called.

    @call_extensions
    def on_ui_initialized(self, model, update_podcast_callback,
            download_episode_callback):
        """Called when the user interface is initialized.

        @param model: A gpodder.model.Model instance
        @param update_podcast_callback: Function to update a podcast feed
        @param download_episode_callback: Function to download an episode
        """
        pass

    @call_extensions
    def on_podcast_subscribe(self, podcast):
        """Called when the user subscribes to a new podcast feed.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_updated(self, podcast):
        """Called when a podcast feed was updated

        This extension will be called even if there were no new episodes.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_update_failed(self, podcast, exception):
        """Called when a podcast update failed.

        @param podcast: A gpodder.model.PodcastChannel instance

        @param exception: The reason.
        """
        pass

    @call_extensions
    def on_podcast_save(self, podcast):
        """Called when a podcast is saved to the database

        This extensions will be called when the user edits the metadata of
        the podcast or when the feed was updated.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_delete(self, podcast):
        """Called when a podcast is deleted from the database

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_episode_save(self, episode):
        """Called when an episode is saved to the database

        This extension will be called when a new episode is added to the
        database or when the state of an existing episode is changed.

        @param episode: A gpodder.model.PodcastEpisode instance
        """
        pass

    @call_extensions
    def on_episode_downloaded(self, episode):
        """Called when an episode has been downloaded

        You can retrieve the filename via episode.local_filename(False)

        @param episode: A gpodder.model.PodcastEpisode instance
        """
        pass

    @call_extensions
    def on_all_episodes_downloaded(self):
        """Called when all episodes has been downloaded
        """
        pass

    @call_extensions
    def on_episodes_context_menu(self, episodes):
        """Called when the episode list context menu is opened

        You can add additional context menu entries here. You have to
        return a list of tuples, where the first item is a label and
        the second item is a callable that will get the episode as its
        first and only parameter.

        Example return value:

        [('Mark as new', lambda episodes: ...)]

        @param episodes: A list of gpodder.model.PodcastEpisode instances
        """
        pass

    @call_extensions
    def on_episode_delete(self, episode, filename):
        """Called just before the episode's disk file is about to be
        deleted."""
        pass

    @call_extensions
    def on_episode_removed_from_podcast(self, episode):
        """Called just before the episode is about to be removed from
        the podcast channel, e.g., when the episode has not been
        downloaded and it disappears from the feed.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_notification_show(self, title, message):
        """Called when a notification should be shown

        @param title: title of the notification
        @param message: message of the notification
        """
        pass

