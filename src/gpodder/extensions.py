# -*- coding: utf-8 -*-
#
# gPodder - A media aggregator and podcast client
# Copyright (c) 2005-2009 Thomas Perl and the gPodder Team
#
# gPodder is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# gPodder is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
Loads and executes user extensions

Extensions are Python scripts in "$GPODDER_HOME/Extensions". Each script must
define a class named "gPodderExtensions", otherwise it will be ignored.

The extensions class defines several callbacks that will be called by gPodder
at certain points. See the methods defined below for a list of callbacks and
their parameters.

For an example extension see examples/extensions.py
"""

import glob
import imp
import inspect
import json
import os
import functools
import shlex
import subprocess
import sys
import re
from datetime import datetime

import gpodder
from gpodder import util
from gpodder.jsonconfig import JsonConfig

import logging
logger = logging.getLogger(__name__)

# The class name that has to appear in a extension module
EXTENSION_CLASS = 'gPodderExtension'

# The variable name that stores the extensions parameters
EXTENSION_PARAMS = 'PARAMS'

# The variable name that stores the extensions parameters
EXTENSION_CONFIG = 'DEFAULT_CONFIG'

# The variable name the directory where the extensions are stored
EXTENSION_FOLDER = 'gpodder_extensions'


def call_extensions(func):
    """Decorator to create handler functions in ExtensionManager

    Calls the specified function in all user extensions that define it.
    """
    method_name = func.__name__

    @functools.wraps(func)
    def handler(self, *args, **kwargs):
        result = None
        for extension_container, state in self.modules:
            if state:
                try:
                    callback = getattr(extension_container.module, method_name, None)
                    if callback is not None:
                        # If the results are lists, concatenate them to show all
                        # possible items that are generated by all extension together
                        cb_res = callback(*args, **kwargs)
                        if isinstance(result, list) and isinstance(cb_res, list):
                            result.extend(cb_res)
                        elif cb_res is not None:
                            result = cb_res
                except Exception, e:
                    logger.error('Error in %s, function %s: %s', extension_container.extension_file,
                            method_name, e, exc_info=True)
        func(self, *args, **kwargs)
        return result

    return handler


class ExtensionParent(object):
    """Super class for every extension"""

    def __init__(self, **kwargs):
        self.metadata = kwargs.get('metadata', None)
        self.config = kwargs.get('config', None)
        self.context_menu_callback = None
        self.read_metadata()

        # this code is needed when running the extensions unittests
        if isinstance(self.config, dict) and self.metadata:
            self.config = JsonConfig(data=json.dumps(self.config))
            self.config = getattr(self.config.extensions, self.metadata['id'])

    def read_metadata(self):
        self.id = None
        self.name = None
        self.desc = None

        if self.metadata is not None:
            self.id = self.metadata.get('id', None)
            self.name = self.metadata.get('name', None)
            self.desc = self.metadata.get('desc', None)

    def check_command(self, cmd):
        """Check if a command line command/program exists"""

        # Prior to Python 2.7.3, this module (shlex) did not support Unicode input.
        cmd = util.sanitize_encoding(cmd)
        program = shlex.split(cmd)[0]
        if util.find_command(program) is None:
            raise ImportError("Couldn't find program '%s'" % program)

    def notify_action(self, action, episode):
        """method to simple use the notification system"""

        if self.config is None or not self.config.enable_notifications:
            return

        name = 'gPodder-Extension'
        if self.name is not None:
            name = '%s: %s' % (name, self.name)

        now = datetime.now()
        msg = "%s(%s): '%s/%s'" % (action, now.strftime('%x %X'),
            episode.channel.title, episode.title)

        gpodder.user_extensions.on_notification_show(name, msg)

    def _show_context_menu(self, episodes):
        """return if a context menu entry should be displayed"""
        return False

    def on_episodes_context_menu(self, episodes):
        """add context menu entry for a specific extension"""

        if self.name is None:
            return None

        if not self._show_context_menu(episodes) or self.context_menu_callback is None:
            return None

        return [(self.name, self.context_menu_callback)]

    def rename_episode_file(self, episode, filename):
        """method for simple update an episode with filename information"""

        if not os.path.exists(filename):
            return

        basename, extension = os.path.splitext(filename)

        episode.download_filename = os.path.basename(filename)
        episode.file_size = os.path.getsize(filename)
        episode.mime_type = util.mimetype_from_extension(extension)
        episode.save()
        episode.db.commit()

    def get_filename(self, episode):
        filename = episode.local_filename(create=False, check_only=True)
        if filename is not None and os.path.exists(filename):
            return filename

        return None


class ExtensionContainer(object):
    """A class which manage one extension"""

    def __init__(self, config=None, filename=None, module=None):
        self.extension_file = filename
        self.module = module
        self._gpo_config = config
        self.config = None
        self.params = None
        self.metadata = None

        if filename is not None and module is None:
            self.metadata = self._load_metadata(filename)
        elif filename is None and module is not None:
            pass
        else:
            logger.error("ExtensionContainer couldn't initialize successfully")

    def _load_module(self, filename):
        basename, extension = os.path.splitext(os.path.basename(filename))
        return imp.load_module(basename, file(filename, 'r'),
            filename, (extension, 'r', imp.PY_SOURCE))

    def _load_metadata(self, filename):
        extension_py = open(filename).read()
        return dict(re.findall("__([a-z]+)__ = '([^']+)'", extension_py))

    def _load_user_prefs(self, module_file):
        if not self.metadata['id'] in self._gpo_config.extensions.keys():
            config = getattr(module_file, EXTENSION_CONFIG, None)
            if config is not None:
                self._gpo_config.register_defaults(config)

        return getattr(self._gpo_config.extensions, self.metadata['id'])

    def load_extension(self):
        """Load a Python module by filename

        Returns an instance of the EXTENSION_CLASS class defined
        in the module, or None if the module does not contain
        such a class.
        """
        try:
            module_file = self._load_module(self.extension_file)
            self.config = self._load_user_prefs(module_file)
            self.params = getattr(module_file, EXTENSION_PARAMS, None)

            extension_class = getattr(module_file, EXTENSION_CLASS, None)
            self.module = extension_class(
                metadata=self.metadata,
                config=self.config
            )

            logger.info('Module loaded: %s', self.extension_file)
        except Exception, e:
            logger.error('Cannot load %s: %s', self.extension_file, e, exc_info=True)
            raise

    def revert_settings(self):
        """revert stored extension settings to the default values"""

        if self.metadata['id'] in self._gpo_config.extensions.keys():
            del self._gpo_config.extensions[self.metadata['id']]

            module_file = self._load_module(self.extension_file)

            config = getattr(module_file, EXTENSION_CONFIG, None)
            if config is not None:
                self._gpo_config.register_defaults(config)
                self._gpo_config.save()


class ExtensionManager(object):
    """Manager class for the extensions

    This class loads all available extensions from the filesystem
    it also holds all "extension"-methods which can be used in an
    extension

    """
    EXTENSIONCONTAINER, STATE = range(2)

    def __init__(self, config):
        self.modules = []
        self._config = config
        enabled_extensions = self._config.extensions.enabled

        pathname = os.path.join(os.path.abspath(gpodder.__path__[0]),
            EXTENSION_FOLDER, '*.py')
        for extension_file in glob.glob(pathname):
            extension_container = ExtensionContainer(
                config=self._config, filename=extension_file)

            enabled = False
            if extension_container.metadata:
                extension_id = extension_container.metadata['id']
                if extension_id in enabled_extensions:
                    error = extension_container.load_extension()
                    if error is None:
                        enabled = True
                    else:
                        enabled_extensions.remove(extension_id)

            self.modules.append((extension_container, enabled))

    def register_extension(self, obj):
        """Register an object that implements some extensions."""

        self.modules.append((ExtensionContainer(module=obj), True))

    def unregister_extension(self, obj):
        """Unregister a previously registered object."""

        extension_module = (ExtensionContainer(module=obj), True)
        if extension_module in self.modules:
            self.modules.remove(extension_module)
        else:
            logger.warn('Unregistered extension which was not registered.')

    def get_extensions(self):
        """Get a list of all loaded extensions and their enabled flag"""

        enabled_extensions = self._config.extensions.enabled
        for index, (extension_container, enabled) in enumerate(self.modules):
            if extension_container.metadata:
                enabled = (extension_container.metadata['id']
                        in enabled_extensions)
                self.modules[index] = (extension_container, enabled)

        return self.modules

    # Define all known handler functions here, decorate them with the
    # "call_extension" decorator to forward all calls to extension scripts that have
    # the same function defined in them. If the handler functions here contain
    # any code, it will be called after all the extensions have been called.

    @call_extensions
    def on_ui_initialized(self, model, update_podcast_callback,
            download_episode_callback):
        """Called when the user interface is initialized.

        @param model: A gpodder.model.Model instance
        @param update_podcast_callback: Function to update a podcast feed
        @param download_episode_callback: Function to download an episode
        """
        pass

    @call_extensions
    def on_podcast_subscribe(self, podcast):
        """Called when the user subscribes to a new podcast feed.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_updated(self, podcast):
        """Called when a podcast feed was updated

        This extension will be called even if there were no new episodes.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_update_failed(self, podcast, exception):
        """Called when a podcast update failed.

        @param podcast: A gpodder.model.PodcastChannel instance

        @param exception: The reason.
        """
        pass

    @call_extensions
    def on_podcast_save(self, podcast):
        """Called when a podcast is saved to the database

        This extensions will be called when the user edits the metadata of
        the podcast or when the feed was updated.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_podcast_delete(self, podcast):
        """Called when a podcast is deleted from the database

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_episode_save(self, episode):
        """Called when an episode is saved to the database

        This extension will be called when a new episode is added to the
        database or when the state of an existing episode is changed.

        @param episode: A gpodder.model.PodcastEpisode instance
        """
        pass

    @call_extensions
    def on_episode_downloaded(self, episode):
        """Called when an episode has been downloaded

        You can retrieve the filename via episode.local_filename(False)

        @param episode: A gpodder.model.PodcastEpisode instance
        """
        pass

    @call_extensions
    def on_all_episodes_downloaded(self):
        """Called when all episodes has been downloaded
        """
        pass

    @call_extensions
    def on_episodes_context_menu(self, episodes):
        """Called when the episode list context menu is opened

        You can add additional context menu entries here. You have to
        return a list of tuples, where the first item is a label and
        the second item is a callable that will get the episode as its
        first and only parameter.

        Example return value:

        [('Mark as new', lambda episodes: ...)]

        @param episodes: A list of gpodder.model.PodcastEpisode instances
        """
        pass

    @call_extensions
    def on_episode_delete(self, episode, filename):
        """Called just before the episode's disk file is about to be
        deleted."""
        pass

    @call_extensions
    def on_episode_removed_from_podcast(self, episode):
        """Called just before the episode is about to be removed from
        the podcast channel, e.g., when the episode has not been
        downloaded and it disappears from the feed.

        @param podcast: A gpodder.model.PodcastChannel instance
        """
        pass

    @call_extensions
    def on_notification_show(self, title, message):
        """Called when a notification should be shown

        @param title: title of the notification
        @param message: message of the notification
        """
        pass
