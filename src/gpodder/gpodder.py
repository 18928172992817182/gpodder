#!/usr/bin/env python
# -*- coding: UTF8 -*-

# Python module src/gpodder/gpodder.py
# Autogenerated from gpodder.glade
# Generated on Wed Mar 29 16:22:49 2006

# Warning: Do not modify any context comment such as #--
# They are required to keep user's code

#
# gPodder
# Copyright (c) 2005 Thomas Perl <thp@perli.net>
# Released under the GNU General Public License (GPL)
#

import os
import gtk
import gobject
import sys

from threading import Event
from string import strip


from SimpleGladeApp import SimpleGladeApp
from SimpleGladeApp import bindtextdomain

from libpodcasts import podcastChannel
from libpodcasts import podcastItem

from libpodcasts import channelsToModel

from librssreader import rssReader
from libopmlwriter import opmlWriter
from libwget import downloadThread
from libwget import downloadStatusManager

from libgpodder import gPodderLib
from libgpodder import gPodderChannelReader
from libgpodder import gPodderChannelWriter

from liblocaldb import localDB

# for isDebugging:
import libgpodder

app_name = "gpodder"
app_version = "unknown" # will be set in main() call
app_authors = [
                "Thomas Perl <thp@perli.net>",
                "", "Contributors / patch writers:",
                "Peter Hoffmann <tosh@cs.tu-berlin.de>",
                "Adrien Beaucreux <informancer@web.de>",
                "Alain Tauch <contrib@maisondubonheur.com>",
                "", "For a complete list of contributors, see AUTHORS file"
              ]
app_copyright = "Copyright (c) 2005-2006 Thomas Perl"
app_website = "http://perli.net/projekte/gpodder/"

#glade_dir = "../data"
glade_dir = "/usr/share/gpodder/"
icon_dir = "/usr/share/gpodder/images/gpodder.png"
locale_dir = ""

bindtextdomain(app_name, locale_dir)


class Gpodder(SimpleGladeApp):
    channels = []
    
    active_item = None
    items_model = None
    
    active_channel = None
    channels_model = None

    channels_loaded = False

    download_status_manager = None
    tooltips = None

    # Local DB
    ldb = None

    def __init__(self, path="gpodder.glade",
                 root="gPodder",
                 domain=app_name, **kwargs):
        path = os.path.join(glade_dir, path)
        SimpleGladeApp.__init__(self, path, root, domain, **kwargs)

    #-- Gpodder.new {
    def new(self):
        if libgpodder.isDebugging():
            print "A new %s has been created" % self.__class__.__name__
        #self.gPodder.set_title( self.gPodder.get_title())
        #self.statusLabel.set_text( "Welcome to gPodder! Suggestions? Mail to: thp@perli.net")
        # set up the rendering of the comboAvailable combobox
        cellrenderer = gtk.CellRendererText()
        self.comboAvailable.pack_start( cellrenderer, True)
        self.comboAvailable.add_attribute( cellrenderer, 'text', 1)

        # set up the rendering of the comboDownloaded combobox
        cellrenderer = gtk.CellRendererText()
        self.comboDownloaded.pack_start( cellrenderer, True)
        self.comboDownloaded.add_attribute( cellrenderer, 'text', 1)

        #See http://www.pygtk.org/pygtk2tutorial/sec-CellRenderers.html
        #gtk.TreeViewColumn( "", gtk.CellRendererToggle(), active=3),
        namecell = gtk.CellRendererText()
        namecell.set_property('cell-background', 'white')
        namecolumn = gtk.TreeViewColumn( "Episode", namecell, text=1)
        namecolumn.add_attribute(namecell, "cell-background", 4)        

        sizecell = gtk.CellRendererText()
        sizecell.set_property('cell-background', 'white')
        sizecolumn = gtk.TreeViewColumn( "Size", sizecell, text=2)
        sizecolumn.add_attribute(sizecell, "cell-background", 4)
        
        for itemcolumn in ( namecolumn, sizecolumn ):
            self.treeAvailable.append_column( itemcolumn)
        
        # columns and renderers for the "downloaded" tab
        # more information: see above..
        namecell = gtk.CellRendererText()
        namecell.set_property('cell-background', 'white')
        namecolumn = gtk.TreeViewColumn( "Episode", namecell, text=1)
        namecolumn.add_attribute(namecell, "cell-background", 4)
        self.treeDownloaded.append_column( namecolumn)
        
        # columns and renderers for "download progress" tab
        episodecell = gtk.CellRendererText()
        episodecolumn = gtk.TreeViewColumn( "Episode", episodecell, text=0)
        
        speedcell = gtk.CellRendererText()
        speedcolumn = gtk.TreeViewColumn( "Speed", speedcell, text=1)
        
        progresscell = gtk.CellRendererProgress()
        progresscolumn = gtk.TreeViewColumn( "Progress", progresscell, value=2)
        
        for itemcolumn in ( episodecolumn, speedcolumn, progresscolumn ):
            self.treeDownloads.append_column( itemcolumn)
    
        new_model = gtk.ListStore( gobject.TYPE_STRING, gobject.TYPE_STRING, gobject.TYPE_INT)
        self.download_status_manager = downloadStatusManager()
        self.treeDownloads.set_model( self.download_status_manager.getModel())
        
        # xml test
        #reader = rssReader()
        #reader.parseXML( "http://www.perli.net", "test.xml")
        #self.channels.append( reader.channel)
        #reader.parseXML( "http://www.lugradio.org/episodes.rss", "episodes.rss")
        #self.channels.append( reader.channel)
        reader = gPodderChannelReader()
        self.channels = reader.read( False)
        self.channels_loaded = True

        # keep Downloaded channels list
        self.downloaded_channels = None
        self.active_downloaded_channels = 0
        
        # update view
        self.updateComboBox()
        self.updateDownloadedComboBox()

        # tooltips :)
        self.tooltips = gtk.Tooltips()
        self.tooltips.set_tip( self.btnEditChannel, "Channel Info")
        
        #Add Drag and Drop Support
        targets = [("text/plain", 0, 2), ('STRING', 0, 3), ('TEXT', 0, 4)]
        self.main_widget.drag_dest_set(gtk.DEST_DEFAULT_ALL, targets, \
                        gtk.gdk.ACTION_DEFAULT | gtk.gdk.ACTION_COPY | \
                        gtk.gdk.ACTION_DEFAULT)
        self.main_widget.connect("drag_data_received", self.drag_data_received)
        self.wNotebook.connect("switch-page", self.switched_notebook)
    #-- Gpodder.new }

    #-- Gpodder custom methods {
    #   Write your own methods here
    def updateComboBox( self):
        self.channels_model = channelsToModel( self.channels)
        
        self.comboAvailable.set_model( self.channels_model)
        try:
            self.comboAvailable.set_active( 0)
        except:
            print "probably no channels found"
        #self.updateTreeView()

    def updateDownloadedComboBox( self):
        # now, update downloaded feeds tab:
        if self.ldb == None:
            self.ldb = localDB()
        # update downloaded_channels list
        self.downloaded_channels = self.ldb.getDownloadedChannelsList()
        self.comboDownloaded.set_model( self.ldb.getDownloadedChannelsModel())
        try:
            self.comboDownloaded.set_active( self.active_downloaded_channels)
        except:
            self.active_downloaded_channels = 0
            if libgpodder.isDebugging():
              print "no downloaded podcasts found.."
    # end of self.updateDownloadedComboBox()
    
    def updateTreeView( self):
        try:
            self.items_model = self.channels[self.active_channel].getItemsModel()
            self.treeAvailable.set_model( self.items_model)
        except:
            if self.items_model != None:
                self.items_model.clear()
            self.showMessage( "<b>No channels found</b>\n\nClick on <b><i>Channels</i></b> &gt; <b><i>Add channel..</i></b> to add a new channel.")
            print "probably no feeds or channels found"
    
    def showMessage( self, message = "some unknown function", title = "gPodder message"):
        dlg = gtk.MessageDialog( self.gPodder, gtk.DIALOG_MODAL, gtk.MESSAGE_INFO, gtk.BUTTONS_OK)
        dlg.set_title( title)
        dlg.set_markup( message)
        
        dlg.run()
        dlg.destroy()

    def showConfirmation( self, message = "Do you really want to do this?", title = "gPodder confirmation"):
        myresult = False
        dlg = gtk.MessageDialog( self.gPodder, gtk.DIALOG_MODAL, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO)
        dlg.set_title( title)
        dlg.set_markup( message)

        if gtk.RESPONSE_YES == dlg.run():
            myresult = True
        
        dlg.destroy()
        if libgpodder.isDebugging():
            print "I Asked: " + message
            print "User answered: " + str(myresult)
        return myresult

    def set_icon(self):
        icon = self.get_icon('gpodder')
        self.main_widget.set_icon(icon)

    def get_icon(self, entry, size=24):
        #path = self.custom_handler.getIconPath(entry, size)
        path = '/usr/share/gpodder/images/gpodder.png'
        if path == None:
            pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, size, size)
            pb.fill(0x00000000)
        else:
            try:
                pb = gtk.gdk.pixbuf_new_from_file_at_size(path, size, size)
            except:
                pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, size, size)
                pb.fill(0x00000000)
        return pb

    def switched_notebook( self, notebook, page, page_num):
        # if we are NOT on the "available downloads" page, disable menu items
        if page_num != 0:
            is_available = False
        else:
            is_available = True
        
        # disable/enable menu items related to only the first notebook tab
        self.itemRemoveChannel.set_sensitive( is_available)
        self.itemEditChannel.set_sensitive( is_available)

        # when switching to last page, update the "downloaded" combo box
        if page_num == 2:
            self.updateDownloadedComboBox()

    def drag_data_received(self, widget, context, x, y, sel, ttype, time):
        #TODO following code is copied from on_itemAddChannel_activate refactor both to new method
        result = sel.data
        if result != None and result != "" and (result[:4] == "http" or result[:3] == "ftp"):
            print "will ADD: " + result
            self.statusLabel.set_text( "Fetching channel index...")
            channel_new = podcastChannel( result)
            channel_new.shortname = "__unknown__"
            self.channels.append( channel_new)
            
            # fetch metadata for that channel
            gPodderChannelWriter().write( self.channels)
            self.channels = gPodderChannelReader().read( False)
            
            # fetch feed for that channel
            gPodderChannelWriter().write( self.channels)
            self.channels = gPodderChannelReader().read( False)
            
            #TODO maybe change to new channel
            self.updateComboBox()
            self.statusLabel.set_text( "")
        else:
            #TODO graphical reaction
            print "unkonwn link format: %s" %result

    #-- Gpodder custom methods }

    #-- Gpodder.close_gpodder {
    def close_gpodder(self, widget, *args):
        if libgpodder.isDebugging():
            print "close_gpodder called with self.%s" % widget.get_name()
        
        if self.channels_loaded:
            gPodderChannelWriter().write( self.channels)

        # cancel downloads by killing all threads in the list
        if self.download_status_manager:
            self.download_status_manager.cancelAll()

        self.gtk_main_quit()
    #-- Gpodder.close_gpodder }

    #-- Gpodder.on_itemUpdate_activate {
    def on_itemUpdate_activate(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_itemUpdate_activate called with self.%s" % widget.get_name()
        reader = gPodderChannelReader()
        #self.channels = reader.read( True)
        #self.labelStatus.set_text( "Updating feed cache...")
        please_wait = gtk.MessageDialog()
        please_wait.set_markup( "<big><b>Updating feed cache</b></big>\n\nPlease wait while gPodder is\nupdating the feed cache...")
        please_wait.show()
        self.channels = reader.read( True)
        please_wait.destroy()
        #self.labelStatus.set_text( "")
        self.updateComboBox()
    #-- Gpodder.on_itemUpdate_activate }

    #-- Gpodder.on_itemPreferences_activate {
    def on_itemPreferences_activate(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_itemPreferences_activate called with self.%s" % widget.get_name()
        prop = Gpodderproperties()
    #-- Gpodder.on_itemPreferences_activate }

    #-- Gpodder.on_itemAddChannel_activate {
    def on_itemAddChannel_activate(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_itemAddChannel_activate called with self.%s" % widget.get_name()
        ch = Gpodderchannel()
        ch.entryURL.set_text( "http://")
        result = ch.requestURL()
        if result != None and result != "" and (result[:4] == "http" or result[:3] == "ftp"):
            if libgpodder.isDebugging():
                print "will ADD: " + result
            self.statusLabel.set_text( "Fetching channel index...")
            channel_new = podcastChannel( result)
            channel_new.shortname = "__unknown__"
            self.channels.append( channel_new)
            channels_should_be = len( self.channels)
            
            # fetch metadata for that channel
            gPodderChannelWriter().write( self.channels)
            self.channels = gPodderChannelReader().read( False)
            
            # fetch feed for that channel
            gPodderChannelWriter().write( self.channels)
            self.channels = gPodderChannelReader().read( False)
            
            # check if gPodderChannelReader has successfully added the channel
            if channels_should_be > len( self.channels):
                self.showMessage( "There has been an error adding the channel.\nMaybe the URL is wrong?")
            
            self.updateComboBox()
            self.statusLabel.set_text( "")
        else:
            if result != None and result != "":
                self.showMessage( "Could not add new channel.\nOnly <b>http://</b> and <b>ftp://</b> URLs supported at the moment.")
    #-- Gpodder.on_itemAddChannel_activate }

    #-- Gpodder.on_itemEditChannel_activate {
    def on_itemEditChannel_activate(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_itemEditChannel_activate called with self.%s" % widget.get_name()
        active = self.active_channel
        try:
          url_old = self.channels[active].url
          title_old = self.channels[active].title
          desc_old = self.channels[active].description
          downloaddir_old = self.channels[active].save_dir # FIXME: should be download dir, but save_dir is more descriptive for now
        except:
          self.showMessage( "Cannot edit this channel.\n\nNo channel found.")
          return
        
        result = Gpodderchannel().requestURL( preset = url_old, title = title_old, description = desc_old, downloaddir = downloaddir_old)
        if result != None and result != "" and (result[:4] == "http" or result[:3] == "ftp"):
            if libgpodder.isDebugging():
                print "will EDIT ID " + str(active) + " FROM " + url_old + " TO " + result
            self.statusLabel.set_text( "Fetching channel index...")
            channel_new = podcastChannel( result)
            channel_new.shortname = "__unknown__"
            new_channels = self.channels[0:active]
            new_channels.append( channel_new)
            new_channels.extend( self.channels[active+1:])
            self.channels = new_channels
        
            # TODO: REFACTOR THE NEXT TWO CODEBLOCKS INTO
            #       A SINGLE FUNCTION (SAME BLOCKS ARE USED IN "ADD FEED")
        
            # fetch metadata for that channel
            gPodderChannelWriter().write( self.channels)
            self.channels = gPodderChannelReader().read( False)
                
            # fetch feed for that channel
            gPodderChannelWriter().write( self.channels)
            self.channels = gPodderChannelReader().read( False)
        
            self.updateComboBox()
            self.statusLabel.set_text( "")
        # end if result != None etc etc
    
    #-- Gpodder.on_itemEditChannel_activate }

    #-- Gpodder.on_itemRemoveChannel_activate {
    def on_itemRemoveChannel_activate(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_itemRemoveChannel_activate called with self.%s" % widget.get_name()
        
        try:
            if self.showConfirmation( "Do you really want to remove this channel?\n\n" + self.channels[self.active_channel].title) == False:
                return
            self.channels.remove( self.channels[self.active_channel])
            gPodderChannelWriter().write( self.channels)
            self.channels = gPodderChannelReader().read( False)
            self.updateComboBox()
        except:
            self.showMessage( "Could not delete channel.\nProbably no channel is selected.")
    #-- Gpodder.on_itemRemoveChannel_activate }

    #-- Gpodder.on_itemExportChannels_activate {
    def on_itemExportChannels_activate(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_itemExportChannels_activate called with self.%s" % widget.get_name()
        if len( self.channels) == 0:
          self.showMessage( "Your channel list is empty. Nothing to export.\n\nGo add some fancy channels! :)")
          return
        dlg = gtk.FileChooserDialog( title="Export to OPML...", parent = None, action = gtk.FILE_CHOOSER_ACTION_SAVE)
        dlg.add_button( gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
        dlg.add_button( gtk.STOCK_SAVE, gtk.RESPONSE_OK)
        response = dlg.run()
        if response == gtk.RESPONSE_OK:
            foutname = dlg.get_filename()
            if foutname[-5:] != ".opml" and foutname[-4:] != ".xml":
                foutname = foutname + ".opml"
            if libgpodder.isDebugging():
                print "=> WILL WRITE OPML TO: " + foutname
            w = opmlWriter( foutname)
            for ch in self.channels:
                w.addChannel( ch)
            w.close()
        # end response is ok
        dlg.destroy()
    # end dlg.run()
    #-- Gpodder.on_itemExportChannels_activate }

    #-- Gpodder.on_itemAbout_activate {
    def on_itemAbout_activate(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_itemAbout_activate called with self.%s" % widget.get_name()
        dlg = gtk.AboutDialog()
        dlg.set_name( app_name)
        dlg.set_version( app_version)
        dlg.set_authors( app_authors)
        dlg.set_copyright( app_copyright)
        dlg.set_website( app_website)
        #
        try:
            dlg.set_logo( gtk.gdk.pixbuf_new_from_file_at_size( icon_dir, 164, 164))
        except:
            None
        #
        dlg.run()
    #-- Gpodder.on_itemAbout_activate }

    #-- Gpodder.on_wNotebook_switch_page {
    def on_wNotebook_switch_page(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_wNotebook_switch_page called with self.%s" % widget.get_name()
    #-- Gpodder.on_wNotebook_switch_page }

    #-- Gpodder.on_comboAvailable_changed {
    def on_comboAvailable_changed(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_comboAvailable_changed called with self.%s" % widget.get_name()
        self.active_channel = self.comboAvailable.get_active()
        self.updateTreeView()
    #-- Gpodder.on_comboAvailable_changed }

    #-- Gpodder.on_btnEditChannel_clicked {
    def on_btnEditChannel_clicked(self, widget, *args):
        if libgpodder.isDebugging():
           print "on_btnEditChannel_clicked called with self.%s" % widget.get_name()
        self.on_itemEditChannel_activate( widget, args)
    #-- Gpodder.on_btnEditChannel_clicked }

    #-- Gpodder.on_treeAvailable_row_activated {
    def on_treeAvailable_row_activated(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_treeAvailable_row_activated called with self.%s" % widget.get_name()
        try:
            selection_tuple = self.treeAvailable.get_selection().get_selected()
            selection_iter = selection_tuple[1]
            url = self.items_model.get_value( selection_iter, 0)
        except:
            self.showMessage( "You have not selected an episode to download.\n\nPlease select one, and I'll download it for you.")
            return

        self.active_item = self.channels[self.active_channel].getActiveByUrl( url)
        
        current_channel = self.channels[self.active_channel]
        current_podcast = current_channel.items[self.active_item]
        filename = current_channel.getPodcastFilename( current_podcast.url)
        if widget.get_name() == "treeAvailable":
            Gpodderepisode().set_episode( current_podcast)    
            return
        
        if os.path.exists( filename) == False and self.download_status_manager.is_download_in_progress( current_podcast.url) == False:
            downloadThread( current_podcast.url, filename, None, self.download_status_manager, current_podcast.title, current_channel, current_podcast, self.ldb).download()
        else:
            self.showMessage( "<big><b>Already downloaded</b></big>\n\nYou have already downloaded this episode.\nOr you are currently downloading it.")
    #-- Gpodder.on_treeAvailable_row_activated }

    #-- Gpodder.on_btnDownload_clicked {
    def on_btnDownload_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnDownload_clicked called with self.%s" % widget.get_name()
        self.on_treeAvailable_row_activated( widget, args)
    #-- Gpodder.on_btnDownload_clicked }

    #-- Gpodder.on_treeDownloads_row_activated {
    def on_treeDownloads_row_activated(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_treeDownloads_row_activated called with self.%s" % widget.get_name()
        selection_tuple = self.treeDownloads.get_selection().get_selected()
        selection_iter = selection_tuple[1]
        if selection_iter != None:
            url = self.download_status_manager.get_url_by_iter( selection_iter)
            title = self.download_status_manager.get_title_by_iter( selection_iter)
            if self.showConfirmation( "Do you really want to cancel this download?\n\n" + title):
                self.download_status_manager.cancel_by_url( url)
        else:
            self.showMessage( "No episode selected - nothing cancelled.")
    #-- Gpodder.on_treeDownloads_row_activated }

    #-- Gpodder.on_btnCancelDownloadStatus_clicked {
    def on_btnCancelDownloadStatus_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnCancelDownloadStatus_clicked called with self.%s" % widget.get_name()
        self.on_treeDownloads_row_activated( widget, None)
    #-- Gpodder.on_btnCancelDownloadStatus_clicked }

    #-- Gpodder.on_comboDownloaded_changed {
    def on_comboDownloaded_changed(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_comboDownloaded_changed called with self.%s" % widget.get_name()
        self.active_downloaded_channels = self.comboDownloaded.get_active()
        try:
          selection_iter = self.comboDownloaded.get_active_iter()
          selected_value = self.comboDownloaded.get_model().get_value( selection_iter, 0)
          if libgpodder.isDebugging():
              print "comboDownloaded_changed with: " + selected_value
          new_model = self.ldb.getDownloadedEpisodesModelByFilename( selected_value)
          self.treeDownloaded.set_model( new_model)
        except:
          # silently ignore the fact that we do not have any downloads
          pass
    #-- Gpodder.on_comboDownloaded_changed }

    #-- Gpodder.on_treeDownloaded_row_activated {
    def on_treeDownloaded_row_activated(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_treeDownloaded_row_activated called with self.%s" % widget.get_name()
        # TODO: refactor with above "on_comboDownloaded_changed" into one method (next three lines)
        try:
          selection_iter = self.comboDownloaded.get_active_iter()
          channel_filename = self.comboDownloaded.get_model().get_value( selection_iter, 0)
          
          selection_tuple = self.treeDownloaded.get_selection().get_selected()
          selection_iter = selection_tuple[1]
          url = self.treeDownloaded.get_model().get_value( selection_iter, 0)
          filename_final = localDB().getLocalFilenameByPodcastURL( channel_filename, url)
          gPodderLib().openFilename( filename_final)
        except:
          self.showMessage( "Could not open this episode.\n\nHave you even selected one?")
    #-- Gpodder.on_treeDownloaded_row_activated }

    #-- Gpodder.on_btnDownloadedExecute_clicked {
    def on_btnDownloadedExecute_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnDownloadedExecute_clicked called with self.%s" % widget.get_name()
        self.on_treeDownloaded_row_activated( widget, args)
    #-- Gpodder.on_btnDownloadedExecute_clicked }

    #-- Gpodder.on_btnDownloadedDelete_clicked {
    def on_btnDownloadedDelete_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnDownloadedDelete_clicked called with self.%s" % widget.get_name()
        
        # Note: same code as in on_treeDownloaded_row_activated()
        try:
            selection_iter = self.comboDownloaded.get_active_iter()
            channel_filename = self.comboDownloaded.get_model().get_value( selection_iter, 0)
            
            selection_tuple = self.treeDownloaded.get_selection().get_selected()
            selection_iter = selection_tuple[1]
            
            url = self.treeDownloaded.get_model().get_value( selection_iter, 0)
            title = self.treeDownloaded.get_model().get_value( selection_iter, 1)
            filename_final = localDB().getLocalFilenameByPodcastURL( channel_filename, url)
            current_channel = self.downloaded_channels[self.comboDownloaded.get_active()]
            if self.showConfirmation( "Do you really want to remove this episode?\n\n" + title) == False:
                return
            
            if current_channel.deleteDownloadedItemByUrlAndTitle( url, title):
                gPodderLib().deleteFilename( filename_final)
                # clear local db cache so we can re-read it
                self.ldb.clear_cache()
                self.updateComboBox()
                self.updateDownloadedComboBox()
        except:
            self.showMessage( "Could not delete selected item.\nHave you selected an episode to delete?")
    #-- Gpodder.on_btnDownloadedDelete_clicked }


class Gpodderstatus(SimpleGladeApp):
    event = None
    channel = None
    podcast = None
    thread = None

    def __init__(self, path="gpodder.glade",
                 root="gPodderStatus",
                 domain=app_name, **kwargs):
        path = os.path.join(glade_dir, path)
        SimpleGladeApp.__init__(self, path, root, domain, **kwargs)

    #-- Gpodderstatus.new {
    def new(self, download_status_manager = None):
        if libgpodder.isDebugging():
            print "A new %s has been created" % self.__class__.__name__
    #-- Gpodderstatus.new }

    #-- Gpodderstatus custom methods {
    #   Write your own methods here
    def setup( self, channel, podcast, download_status_manager):
        self.channel = channel
        self.podcast = podcast
        
        self.labelFrom.set_markup( "<b>" + self.channel.title + "</b>")
        self.labelFilename.set_markup( "<b>" + self.podcast.title + "</b>")
        
    
    def download( self):
        self.thread.download()
        
        while self.event.isSet() == False:
            self.event.wait( 0.1)
            
            self.labelSpeed.set_text( self.thread.speed)
            self.progressBar.set_fraction( float(self.thread.percentage))
            
            while gtk.events_pending():
                gtk.main_iteration( False)

        self.gPodderStatus.destroy()
    
    def cancel( self):
        self.on_btnCancel_clicked( self.btnCancel, None)
    #-- Gpodderstatus custom methods }

    #-- Gpodderstatus.on_gPodderStatus_destroy {
    def on_gPodderStatus_destroy(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_gPodderStatus_destroy called with self.%s" % widget.get_name()
    #-- Gpodderstatus.on_gPodderStatus_destroy }

    #-- Gpodderstatus.on_btnCancel_clicked {
    def on_btnCancel_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnCancel_clicked called with self.%s" % widget.get_name()
        
        if self.thread != None:
            self.thread.cancel()

        while self.event != None and self.event.isSet() == False:
            None
        
        self.gPodderStatus.destroy()
    #-- Gpodderstatus.on_btnCancel_clicked }


class Gpodderchannel(SimpleGladeApp):
    def __init__(self, path="gpodder.glade",
                 root="gPodderChannel",
                 domain=app_name, **kwargs):
        waiting = None
        url = ""
        result = False
        path = os.path.join(glade_dir, path)
        SimpleGladeApp.__init__(self, path, root, domain, **kwargs)

    #-- Gpodderchannel.new {
    def new(self):
        if libgpodder.isDebugging():
            print "A new %s has been created" % self.__class__.__name__
    #-- Gpodderchannel.new }

    #-- Gpodderchannel custom methods {
    #   Write your own methods here
    def requestURL( self, preset = None, title = "(unknown)", description = "(unknown)", downloaddir = None):
        if preset != None:
            self.entryURL.set_text( preset)

        if downloaddir != None:
            self.downloadTo.set_text( downloaddir)

        self.channel_title.set_markup( "<b>%s</b>" % title)
        b = gtk.TextBuffer()
        b.set_text( description)
        self.channel_description.set_buffer( b)
        
        self.waiting = Event()
        while self.waiting.isSet() == False:
            self.waiting.wait( 0.01)
            while gtk.events_pending():
                gtk.main_iteration( False)
        
        if self.result == True:
            return self.url
        else:
            return None
    #-- Gpodderchannel custom methods }

    #-- Gpodderchannel.on_gPodderChannel_destroy {
    def on_gPodderChannel_destroy(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_gPodderChannel_destroy called with self.%s" % widget.get_name()
        self.result = False
    #-- Gpodderchannel.on_gPodderChannel_destroy }

    #-- Gpodderchannel.on_btnOK_clicked {
    def on_btnOK_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnOK_clicked called with self.%s" % widget.get_name()
        self.url = self.entryURL.get_text()
        self.gPodderChannel.destroy()
        self.result = True

        if self.waiting != None:
            self.waiting.set()
    #-- Gpodderchannel.on_btnOK_clicked }

    #-- Gpodderchannel.on_btnCancel_clicked {
    def on_btnCancel_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnCancel_clicked called with self.%s" % widget.get_name()
        self.gPodderChannel.destroy()
        self.result = False
        
        if self.waiting != None:
            self.waiting.set()
    #-- Gpodderchannel.on_btnCancel_clicked }


class Gpodderproperties(SimpleGladeApp):
    def __init__(self, path="gpodder.glade",
                 root="gPodderProperties",
                 domain=app_name, **kwargs):
        path = os.path.join(glade_dir, path)
        SimpleGladeApp.__init__(self, path, root, domain, **kwargs)

    #-- Gpodderproperties.new {
    def new(self):
        if libgpodder.isDebugging():
            print "A new %s has been created" % self.__class__.__name__
        gl = gPodderLib()
        self.httpProxy.set_text( gl.http_proxy)
        self.ftpProxy.set_text( gl.ftp_proxy)
        self.openApp.set_text( gl.open_app)
        # if the symlink exists, set the checkbox active
        self.cbDesktopSymlink.set_active( gPodderLib().getDesktopSymlink())
    #-- Gpodderproperties.new }

    #-- Gpodderproperties custom methods {
    #   Write your own methods here
    #-- Gpodderproperties custom methods }

    #-- Gpodderproperties.on_gPodderProperties_destroy {
    def on_gPodderProperties_destroy(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_gPodderProperties_destroy called with self.%s" % widget.get_name()
    #-- Gpodderproperties.on_gPodderProperties_destroy }

    #-- Gpodderproperties.on_btnOK_clicked {
    def on_btnOK_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnOK_clicked called with self.%s" % widget.get_name()
        gl = gPodderLib()
        gl.http_proxy = self.httpProxy.get_text()
        gl.ftp_proxy = self.ftpProxy.get_text()
        gl.open_app = self.openApp.get_text()
        gl.propertiesChanged()
        # create or remove symlink to download dir on desktop
        if self.cbDesktopSymlink.get_active():
            gl.createDesktopSymlink()
        else:
            gl.removeDesktopSymlink()
        self.gPodderProperties.destroy()
    #-- Gpodderproperties.on_btnOK_clicked }

    #-- Gpodderproperties.on_btnCancel_clicked {
    def on_btnCancel_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnCancel_clicked called with self.%s" % widget.get_name()
        self.gPodderProperties.destroy()
    #-- Gpodderproperties.on_btnCancel_clicked }


class Gpodderepisode(SimpleGladeApp):

    def __init__(self, path="gpodder.glade",
                 root="gPodderEpisode",
                 domain=app_name, **kwargs):
        path = os.path.join(glade_dir, path)
        SimpleGladeApp.__init__(self, path, root, domain, **kwargs)

    #-- Gpodderepisode.new {
    def new( self):
        if libgpodder.isDebugging():
            print "A new %s has been created" % self.__class__.__name__
    #-- Gpodderepisode.new }

    #-- Gpodderepisode custom methods {
    #   Write your own methods here
    def set_episode( self, episode):
        self.episode_title.set_markup( '<big><b>%s</b></big>' % episode.title)
        b = gtk.TextBuffer()
        b.set_text( strip( episode.description))
        self.episode_description.set_buffer( b)
    #-- Gpodderepisode custom methods }

    #-- Gpodderepisode.on_btnCloseWindow_clicked {
    def on_btnCloseWindow_clicked(self, widget, *args):
        if libgpodder.isDebugging():
            print "on_btnCloseWindow_clicked called with self.%s" % widget.get_name()
        self.gPodderEpisode.destroy()
    #-- Gpodderepisode.on_btnCloseWindow_clicked }


#-- main {

def main( __version__ = None):
    global app_version
    
    gtk.gdk.threads_init()
    app_version = __version__
    g_podder = Gpodder()
    #g_podder_status = Gpodderstatus()
    #g_podder_channel = Gpodderchannel()
    #g_podder_properties = Gpodderproperties()
    #g_podder_episode = Gpodderepisode()

    g_podder.set_icon()
    g_podder.run()

if __name__ == "__main__":
    print "please run the gpodder binary, not this file"
    sys.exit( -1)

#-- main }
